### 1. 核心目標：構建組譯器
第六章的主要目標是開發一個程式（組譯器），將用 **Hack 組合語言**（Assembly Language）編寫的符號程式（`.asm` 檔），翻譯成電腦硬體可以直接執行的 **Hack 二進位代碼**（Binary Code, `.hack` 檔）。

組譯器是軟體層級中最基礎的翻譯器。它的輸入是人類可讀的助記符（mnemonics），輸出是機器可讀的 16 位元 0/1 字串序列,。

### 2. 翻譯機制：處理指令與格式
組譯器必須逐行讀取原始碼，並處理以下三類元素：

#### A. 空白與註解 (White Space)
組譯器需要忽略所有的空行、縮排以及以 `//` 開頭的註解。這些元素是為了讓人類閱讀方便，對機器執行沒有意義。

#### B. 指令翻譯 (Instruction Translation)
Hack 語言只有兩種指令，組譯器需將其轉換為 16 位元的二進位碼：
*   **A-指令 (@xxx)：**
    *   格式為 `0vvv...v`。
    *   如果 `xxx` 是十進位數值，直接轉換為二進位。
    *   如果 `xxx` 是符號（如 `@sum`），則需要查詢符號表解析其位址,。
*   **C-指令 (dest=comp;jump)：**
    *   格式為 `111accccccdddjjj`。
    *   組譯器需要將符號形式的計算（comp）、目的地（dest）和跳轉（jump）欄位，對照二進位代碼表進行轉換,。例如，將 `D=D+1` 翻譯成對應的位元串。

### 3. 核心挑戰：符號處理 (Symbol Handling)
這是本章最複雜的部分。為了讓程式設計更靈活，Hack 語言允許使用符號來代替具體的記憶體位址。組譯器必須能解析以下三種符號：
1.  **預定義符號 (Predefined symbols)：** 如 `R0`-`R15`, `SCREEN`, `KBD`, `SP`, `LCL` 等，它們對應到固定的 RAM 位址。
2.  **標籤符號 (Label symbols)：** 用於標記程式跳轉的位置，由 `(LABEL)` 形式宣告。它們對應到下一行指令在 ROM 中的位址。
3.  **變數符號 (Variable symbols)：** 程式設計師自定義的變數（如 `@i`, `@sum`）。組譯器會將其映射到從 RAM 位址 16 開始的記憶體空間,。

### 4. 演算法策略：兩遍掃描 (Two-Pass Process)
為了解決「前向引用」（Forward Reference）的問題（即在定義標籤之前就先跳轉到該標籤），講義強烈建議採用**兩遍掃描**的策略,：

*   **第一遍掃描 (First Pass)：**
    *   讀取整個程式，只關注 `(label)` 宣告。
    *   計算指令的行號（ROM 位址），將標籤符號及其對應的位址加入**符號表 (Symbol Table)**。
    *   此階段**不產生**任何二進位代碼。
*   **第二遍掃描 (Second Pass)：**
    *   重新從頭讀取程式，逐行翻譯指令。
    *   如果是 A-指令中的變數符號（如 `@sum`），先查符號表。如果表中沒有，則將其視為新變數，分配下一個可用的 RAM 位址（從 16 開始），並加入表中。
    *   將所有指令翻譯成二進位碼並輸出到檔案,。

### 5. 建議的軟體架構
為了實作組譯器，講義建議將程式模組化為四個部分：
1.  **Parser (解析器)：** 負責讀取檔案，去除空白與註解，並將指令分解為各個欄位（如 symbol, dest, comp, jump）。
2.  **Code (代碼模組)：** 提供查表功能，將組合語言的助記符（如 "JGT", "M+1"）轉換為對應的二進位位元。
3.  **SymbolTable (符號表)：** 管理符號與位址的對應關係（雜湊表），支援新增 (`addEntry`) 和查詢 (`contains`, `getAddress`)。
4.  **HackAssembler (主程式)：** 驅動整個翻譯過程，協調上述模組，管理檔案輸入輸出。

### 6. 專案執行與測試 (Project 6)
*   **開發階段：** 建議分兩階段。第一階段先寫一個不處理符號的「基本組譯器」（只處理數值位址）；第二階段再加入符號處理功能,。
*   **測試程式：** 使用課程提供的 `Add.asm`（無符號）、`Max.asm`、`Rect.asm` 和 `Pong.asm`（大型乒乓球遊戲，作為壓力測試）進行驗證,。
*   **驗證方式：** 您產生的 `.hack` 檔案必須與課程提供的標準組譯器產生的輸出完全一致（bit-wise identical）。可以使用提供的 `TextComparer` 工具或 CPU 模擬器來驗證,。
*   **手動選項：** 如果您沒有程式設計經驗，專案也允許您使用文字編輯器手動進行翻譯，以證明您對翻譯邏輯的理解。

總結來說，第六章通過實作組譯器，揭示了符號代碼如何轉變為機器實體能理解的信號，是理解計算機系統軟硬體介面的關鍵一步。