這是一組關於**編譯器設計（Compiler Design）**的教學範例程式碼，主要使用 Python 實作了一個名為 **p0** 的簡易語言編譯器。

這些檔案展示了從最基礎的文法概念，進階到實作一個能處理變數、迴圈 (`while`)、條件判斷 (`if`)，甚至函數呼叫 (`function`) 的編譯器前端。

以下我將為您詳細解釋這三個檔案的內容與邏輯：

### 1. `09/01-anbn/anbn.py` (理論基礎：上下文無關文法)

這是一個暖身程式，用來展示編譯器理論中的 **上下文無關文法 (Context-Free Grammar, CFG)** 概念。

* **目標**：生成形式為 a^n b^n 的字串（例如 `ab`, `aabb`, `aaabbb`）。這通常用來證明正規表達式（Regular Expression）的不足，需要用到遞迴（堆疊）結構。
* **邏輯**：它模擬了文法規則 S \rightarrow aSb \mid ab。
* **遞迴終止 (Base Case)**：當 n=1，回傳 "ab"。
* **遞迴步驟 (Recursive Step)**：當 n>1，回傳 "a" + `S(n-1)` + "b"。


* **意義**：這是理解「遞迴下降解析器 (Recursive Descent Parser)」的基礎，後面的編譯器就是利用這種遞迴結構來解析程式碼的巢狀結構（如 `if` 裡面還有 `if`）。

---

### 2. `09/04-p0ifwhile/compiler.py` (基礎編譯器：變數與流程控制)

這是一個能夠將原始碼編譯成 **中間碼 (Intermediate Representation, IR)** 的編譯器。

#### 核心架構：

1. **詞法分析 (Tokenizer / Lexer)**：
* 使用 Python 的 `re` (正規表達式) 模組，將原始字串切分成一個個 Token（如 `KEYWORD`, `ID`, `NUMBER`, `OP`）。
* 例如：`let i = 1` 會被切成 `('KEYWORD', 'let')`, `('ID', 'i')`, `('OP', '=')`, `('NUMBER', '1')`。


2. **語法分析與代碼生成 (Parser & Code Gen)**：
* 使用 **遞迴下降法 (Recursive Descent)**。例如 `parse_statement` 會判斷關鍵字來決定呼叫 `parse_while` 還是 `parse_if`。
* **中間碼格式 (IR)**：採用四元組 `(OP, ARG1, ARG2, RESULT)`。這是一種常見的線性中間表示法。



#### 關鍵實作細節：

* **表達式解析 (`parse_expression`)**：處理加法等運算。它會生成臨時變數（如 `t0`, `t1`）來儲存中間運算結果。
* 例如 `i + 1` 會變成 `(+, i, 1, t0)`。


* **While 迴圈 (`parse_while`)**：
* 生成兩個標籤：`start_label` (迴圈開始) 和 `end_label` (迴圈結束)。
* 生成邏輯：
1. 標記 `start_label`。
2. 計算條件。
3. `if_false` 條件不成立跳轉到 `end_label`。
4. 執行區塊內容。
5. `goto` 跳回 `start_label`。
6. 標記 `end_label`。




* **If 判斷 (`parse_if`)**：
* 類似 While，但利用 `else_label` 處理分支。



---

### 3. `09/05-p0func/compiler.py` (進階編譯器：函數支援)

這是前一個版本的升級版，新增了對 **函數 (Function)** 的支援。這使得語言從單純的腳本變成了結構化程式語言。

#### 新增功能：

1. **新關鍵字**：`fn` (定義函數), `return` (回傳), `call` (呼叫), `param` (參數傳遞)。
2. **函數定義 (`parse_function_def`)**：
* 解析 `fn name(params) { ... }`。
* 生成 `func_entry` 標籤，標示函數入口。
* 生成 `recv` 指令，表示接收參數。


3. **函數呼叫 (`parse_function_call`)**：
* 解析 `name(arg1, arg2)`。
* **參數傳遞**：先生成 `param arg1`, `param arg2` 指令將參數推入堆疊（或暫存區）。
* **呼叫指令**：生成 `call func_name, argc, result_temp`。


4. **檔案輸入**：
* 不再使用硬編碼 (Hardcoded) 的字串，而是透過 `sys.argv` 讀取外部檔案。這更像一個真正的編譯器工具。



#### IR 指令範例對照：

假設原始碼是：

```javascript
fn add(a, b) {
    return a + b;
}
let x = add(3, 5);

```

編譯出的 IR 大致如下：

```text
goto         L0         -          -          (跳過函數定義，去執行主程式)
func_entry   add        -          -          (函數入口)
recv         a          -          -          (接收參數 a)
recv         b          -          -          (接收參數 b)
+            a          b          t0         (計算 a+b)
return       t0         -          -          (回傳結果)
label        L0         -          -          (主程式開始)
param        3          -          -          (準備參數 1)
param        5          -          -          (準備參數 2)
call         add        2          t1         (呼叫函數，結果存入 t1)
=            t1         -          x          (賦值給 x)

```

### 總結

這組程式碼是一個非常好的編譯器入門教材：

1. **anbn.py** 建立了遞迴的概念。
2. **p0ifwhile** 實作了基本的指令翻譯與流程控制（標籤與跳轉）。
3. **p0func** 加入了函數呼叫慣例（Calling Convention）的雛形（參數傳遞與回傳）。

如果您正在學習如何寫一個編譯器，這是一個從「正則表達式切分 Token」到「生成組合語言前的中間碼」的完整微縮模型。