**第十一章：編譯器 II - 代碼生成 (Compiler II: Code Generation)**

如果說第十章是讓編譯器「看懂」程式碼（語法分析），那麼**第十一章就是讓編譯器「學會翻譯」**。

在這一章，您的目標是將第十章建立的語法分析器（Syntax Analyzer）升級為一個**全功能的編譯器**。您將不再輸出用於除錯的 XML 檔案，而是生成可以直接在虛擬機上執行的 **VM 代碼 (VM Code)**,。

這一章是整個軟體層級中最複雜、但也最核心的部分，它連接著高階語言（Jack）與低階虛擬機（VM）。以下是本章的詳細技術解構：

### 1. 核心任務：從語法樹到堆疊機
第十章的解析器使用遞迴下降法（Recursive Descent）遍歷程式結構。在第十一章，您需要在遍歷這些結構的同時，輸出對應的 VM 指令。

*   **表達式 (Expressions)：** 將中綴表示法（如 `x + y`）轉換為堆疊機的後綴邏輯。
    *   例如：讀到 `x + y` 時，編譯器需生成：
        ```
        push local 0  // 假設 x 是 local 0
        push local 1  // 假設 y 是 local 1
        add           // 執行加法
        ```
    *   這確保了運算結果會留在堆疊頂端，供後續使用,。

*   **流程控制 (Flow Control)：**
    *   **`if` 和 `while` 語句：** 需要自動產生標籤（Label，如 `L1`, `L2`）並配合 `goto` 和 `if-goto` 指令來控制執行流程。
    *   例如 `while` 迴圈通常涉及：定義開頭標籤 -> 計算條件 -> `not` -> `if-goto` 結束標籤 -> 執行內容 -> `goto` 開頭標籤 -> 定義結束標籤。

### 2. 關鍵模組：符號表 (Symbol Table)
這是本章新增的最重要模組。編譯器必須「記住」變數的資訊才能正確翻譯。當編譯器遇到變數 `x` 時，它不能只輸出 `x`，它必須知道 `x` 實際上對應到虛擬機的哪個記憶體片段（例如：`local 2` 或 `field 0`）。

您需要實作一個 `SymbolTable` 來管理這些資訊：
*   **變數屬性：** 記錄每個識別字（Identifier）的 **名稱 (Name)**、**類型 (Type)**（如 `int`, `boolean`, `Point`）、**種類 (Kind)**（`static`, `field`, `argument`, `local`）以及 **索引 (Index)**。
*   **作用域 (Scope) 管理：**
    *   **Class Level：** 儲存 `static` 和 `field` 變數。
    *   **Subroutine Level：** 儲存 `argument` 和 `local` 變數。每次編譯新的函數時，這張表需要被重置,。

### 3. 物件導向的翻譯魔法
這一章揭示了高階語言如何處理物件、方法與陣列：

*   **建構子 (Constructors)：**
    *   當編譯 `new` 方法時，編譯器需先計算該物件需要多少記憶體空間（根據 `field` 的數量），呼叫 `Memory.alloc` 分配空間，並將回傳的基底位址設為 `this` 指標,。
*   **方法呼叫 (Methods)：**
    *   在 Jack（以及許多 OOP 語言）中，呼叫 `object.method(arg)` 時，編譯器會在幕後將 `object` 也就是 `this` 作為**第 0 個參數**推入堆疊 (`push argument 0`)，然後才推入其他參數。這就是為什麼方法內部可以存取該物件的屬性,。
*   **陣列 (Arrays)：**
    *   處理 `arr[i]` 這種陣列存取時，需要使用 VM 的 `that` 指標進行間接定址。公式大致為：`push arr`, `push i`, `add`, `pop pointer 1` (設定 that 指向 arr+i)，最後使用 `push/pop that 0` 來存取資料-。

### 4. 專案執行步驟 (Project 11)
為了降低難度，講義建議分兩階段開發：

*   **第一階段：符號表與變數處理**
    *   建立 `SymbolTable` 模組。
    *   修改第 10 章的解析器，讓它在輸出 XML 時能附帶變數的資訊（例如：定義了變數 `x`，種類是 `local`，索引是 `0`）。這用於驗證您的符號表是否正確運作,。

*   **第二階段：代碼生成**
    *   建立 `VMWriter` 模組（負責輸出 `push`, `pop`, `add`, `call` 等 VM 指令）。
    *   移除 XML 輸出的程式碼，替換為呼叫 `VMWriter`。
    *   **依序測試：** 使用課程提供的測試檔案進行漸進式開發：
        1.  `Seven`: 簡單的算術運算。
        2.  `ConvertToBin`: 測試記憶體存取、表達式與流程控制。
        3.  `Square`: 測試類別、建構子與方法呼叫。
        4.  `Average`: 測試陣列與字串。
        5.  `Pong`: 完整的遊戲測試（最終大魔王）。
        6.  `ComplexArrays`: 複雜的陣列操作,。

### 總結
第 11 章是您完成 Nand2Tetris 軟體構建的最後一塊拼圖（在作業系統之前）。完成後，您將擁有一個能將高階 Jack 語言編譯成虛擬機代碼的完整編譯器。這意味著您親手寫的遊戲（如 Project 9）現在可以通過您自己的編譯器（Project 10+11），在您自己的虛擬機翻譯器（Project 8）翻譯後，在您自己的電腦架構（Project 1-5）上執行。這是真正的全端理解。