這段 `write_arithmetic` 函式是 VM 翻譯器的核心部分之一，負責將 **算術 (Arithmetic)** 與 **邏輯 (Logical)** 的 VM 指令轉換成 Hack 組合語言。

這些指令的操作對象都是 **堆疊 (Stack)**。在 Hack 電腦架構中，`SP` (Stack Pointer) 永遠指向堆疊頂端**下一個**空白的位置，所以真正的數據是在 `SP-1`。

我將這段程式碼分為三類詳細解釋：

-----

### 1\. 二元運算 (Binary Operations)

**指令：** `add` (加), `sub` (減), `and` (邏輯且), `or` (邏輯或)

這些運算需要兩個運算元（Operands）。邏輯是：從堆疊彈出兩個數字 `y` 和 `x`，計算 `x op y`，然後將結果放回堆疊頂端。

**程式碼邏輯分析 (`add` 為例)：**

```c
// VM: add
fprintf(out, "@SP\nAM=M-1\nD=M\nA=A-1\nM=D+M\n");
```

**組合語言逐行解釋：**

1.  `@SP`：選取堆疊指標暫存器 (RAM[0])。
2.  `AM=M-1`：這是一行雙重指令。
      * `M-1`：將 SP 的值減 1（因為要取出最上面的數據 `y`）。
      * `A=`：將位址暫存器 A 更新為減 1 後的位址（現在指向 `y`）。
      * `M=`：將 RAM[0] (SP) 的值正式更新為減 1。
      * **結果**：SP 指向了 `y`，且 A 暫存器也指向 `y` 的記憶體位址。
3.  `D=M`：將 `y` 的值讀入 D 暫存器。
4.  `A=A-1`：將 A 暫存器再減 1。現在 A 指向 `x` 的記憶體位址（SP 不變，仍指向 `y` 的位置，這其實是為了節省指令，直接操作 `x` 的位置來存放結果）。
5.  `M=D+M` (或 `M=M-D`, `M=D&M` 等)：
      * 計算 `D` (即 `y`) 加上 `M` (即 `x`)。
      * 將結果存回 `M` (即原本 `x` 的位置)。
      * **結果**：運算完成，結果取代了 `x`，`SP` 也已經正確地指向了結果之後的位置（因為步驟 2 減了一次）。

**特別注意 `sub`：**

  * `M=M-D`：這是 `x - y`。順序很重要，堆疊最上面彈出來的是 `y` (減數)，下面的是 `x` (被減數)。

-----

### 2\. 一元運算 (Unary Operations)

**指令：** `neg` (負號, -x), `not` (邏輯反, \!x)

只需要一個運算元。邏輯是：修改堆疊頂端的數值。

**程式碼邏輯分析 (`neg` 為例)：**

```c
// VM: neg
fprintf(out, "@SP\nA=M-1\nM=-M\n");
```

**組合語言逐行解釋：**

1.  `@SP`：選取 SP。
2.  `A=M-1`：
      * 讀取 SP 的值，減 1。
      * 將結果放入 A 暫存器。
      * **注意**：這裡沒有更新 `M` (SP 本身)，因為我們不需要改變堆疊的高度，只是要修改內容。
3.  `M=-M` (或 `M=!M`)：
      * 讀取位址 A 的值 (`x`)，取負號。
      * 存回位址 A。

-----

### 3\. 比較運算 (Comparison Operations)

**指令：** `eq` (等於), `gt` (大於), `lt` (小於)

這部分最複雜，因為 Hack 組合語言沒有單條指令可以直接比較並產生布林值。
**邏輯**：

1.  取出 `y` 和 `x`。
2.  計算 `x - y`。
3.  根據差值是否為 0 (eq)、大於 0 (gt) 或小於 0 (lt) 進行跳轉。
4.  如果條件成立，將堆疊頂端設為 `TRUE` (-1)。
5.  如果條件不成立，將堆疊頂端設為 `FALSE` (0)。

**程式碼邏輯分析 (`eq` 為例)：**

```c
// VM: eq
// 1. 取出兩數相減
fprintf(out, "@SP\nAM=M-1\nD=M\nA=A-1\nD=M-D\n");

// 2. 條件判斷與跳轉
fprintf(out, "@TRUE_%d\nD;JEQ\n", label_count); // 若 D == 0，跳去 TRUE

// 3. 設定為 FALSE (0) 的情況
fprintf(out, "@SP\nA=M-1\nM=0\n");              // 將堆疊頂端設為 0
fprintf(out, "@END_%d\n0;JMP\n", label_count);  // 跳過 TRUE 區塊

// 4. 設定為 TRUE (-1) 的情況
fprintf(out, "(TRUE_%d)\n@SP\nA=M-1\nM=-1\n", label_count); // 將堆疊頂端設為 -1

// 5. 結束標籤
fprintf(out, "(END_%d)\n", label_count);

// 6. 更新標籤計數
label_count++;
```

**詳細解釋：**

1.  **相減 (`D=M-D`)**：
      * 這部分和 `sub` 指令很像，只是結果存在 `D` 暫存器中，而不是寫回記憶體。因為我們只需要知道差值，不需要保留差值。
2.  **`@TRUE_%d` 與 `D;JEQ`**：
      * `%d` 是用 `label_count` 填入的數字 (例如 `TRUE_0`)，確保每次比較的標籤名不重複。
      * `D;JEQ`：如果 `D` (差值) 等於 0，表示 `x == y`，則跳轉到 `TRUE` 標籤。
      * 對於 `gt` 使用 `JGT` (Jump if Greater Than)，對於 `lt` 使用 `JLT` (Jump if Less Than)。
3.  **FALSE 區塊**：
      * 如果沒跳轉，程式會繼續往下執行。
      * `@SP \n A=M-1 \n M=0`：將堆疊頂端 (`x` 原本的位置) 設為 `0` (False)。
      * `@END_%d \n 0;JMP`：無條件跳轉到結尾，避開下面 TRUE 的設定程式碼。
4.  **TRUE 區塊 (`(TRUE_%d)`)**：
      * `@SP \n A=M-1 \n M=-1`：將堆疊頂端設為 `-1`。在 Hack 電腦中，16位元全為 1 (`1111111111111111`) 代表 `-1`，這也是 Hack 的 `True`。

### 總結

這個函式巧妙地處理了三個層次：

1.  **堆疊指標管理**：利用 `AM=M-1` 這種技巧同時移動指標並獲取位址。
2.  **Hack 硬體限制**：因為 Hack 的 CPU 一次只能做簡單運算，所以必須把 `pop x, pop y, add` 拆解成多個步驟。
3.  **流程控制**：利用組合語言的 Label 和 Jump 來實現高階語言中的 `if (x == y)` 邏輯。