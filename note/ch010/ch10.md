第十章（Chapter 10）的標題是 **「編譯器 I：語法分析 (Compiler I: Syntax Analysis)」**。

這章是構建 Jack 編譯器（Compiler）的第一步。編譯器的開發是一個龐大的工程，因此課程將其分為兩個部分：
*   **第十章（本章）：** 專注於 **語法分析 (Syntax Analysis)**，目標是讀取 Jack 原始碼並理解其結構，輸出為 XML 格式以供驗證,。
*   **第十一章（下一章）：** 專注於 **代碼生成 (Code Generation)**，將理解後的結構轉換為虛擬機代碼 (VM Code)。

以下是第十章的詳細內容拆解：

### 1. 核心目標：語法分析器 (Syntax Analyzer)
本章的任務是編寫一個程式，它能讀入 `.jack` 檔案（高階語言），並將其解析為 **解析樹 (Parse Tree)** 的結構,。
為了驗證您的分析器是否正確理解了程式碼結構，本章要求您將解析結果輸出為 **XML 格式**,。

### 2. 兩個主要模組
語法分析的過程通常分為兩個階段，您需要實作兩個對應的軟體模組：

#### A. 詞法分析 (Tokenizing) - `JackTokenizer`
這是編譯器的第一道工序。它的工作是將原始碼（一長串字元）分解為有意義的 **「標記 (Tokens)」**。
*   **忽略內容：** 必須忽略所有的註解（`//` 或 `/* ... */`）和空白字元,。
*   **識別標記：** 將剩餘的內容分類為以下五種標記類型,：
    *   **關鍵字 (keyword)：** 如 `class`, `method`, `int`, `while` 等。
    *   **符號 (symbol)：** 如 `{`, `}`, `=`, `+`, `;` 等。
    *   **整數常數 (integerConstant)：** 如 `17`, `0`。
    *   **字串常數 (stringConstant)：** 如 `"Hello World"`。
    *   **識別字 (identifier)：** 程式設計師自定義的名稱，如變數名 `count` 或函數名 `main`。

#### B. 語法解析 (Parsing) - `CompilationEngine`
這是本章的核心。它的工作是讀取 `JackTokenizer` 產生的標記流，並根據 **Jack 語言的文法 (Grammar)** 將其組織成有結構的層次,。
*   **遞迴下降解析 (Recursive Descent Parsing)：** 這是講義推薦的實作策略。您會為每一個非終端符號（Non-terminal）編寫一個方法。
    *   例如：`compileClass()` 方法會呼叫 `compileSubroutine()`，而 `compileSubroutine()` 內部又會呼叫 `compileStatements()`，依此類推,。
*   **XML 輸出：** 解析器需要將讀到的結構用 XML 標籤包起來。
    *   例如，讀到 `while (x)` 時，輸出可能會像這樣：
        ```xml
        <whileStatement>
          <keyword> while </keyword>
          <symbol> ( </symbol>
          <expression> ... </expression>
          <symbol> ) </symbol>
          ...
        </whileStatement>
        ```

### 3. Jack 語言文法 (Grammar)
為了寫出解析器，您必須參考課程提供的 **Jack 文法規範**。這些規則定義了程式的結構，例如,：
*   **程式結構：** 一個 `class` 包含 `field`/`static` 變數宣告，以及 `constructor`/`function`/`method` 子程序。
*   **語句 (Statements)：** Jack 有 5 種語句：`let`, `if`, `while`, `do`, `return`。
*   **表達式 (Expressions)：** 包含運算子（`+`, `-`, `*` 等）與運算元。

### 4. 專案執行步驟 (Project 10)
講義建議將開發分為三個階段進行，以利於除錯,：

1.  **階段 0 (Tokenizer)：** 先實作 `JackTokenizer`，並寫一個簡單的測試程式，將所有標記輸出為 XML（如 `<token>...</token>`），確認分詞功能正確。
2.  **階段 1 (基本分析)：** 實作 `CompilationEngine`，但先忽略表達式 (Expressions) 和陣列的複雜邏輯。使用課程提供的 `ExpressionlessSquare` 測試檔案進行驗證。
3.  **階段 2 (完整分析)：** 補完表達式與陣列的解析邏輯，使用 `Square` 和 `ArrayTest` 進行最終測試。

### 5. 為什麼要輸出 XML？
這是一個過渡性的步驟。在第 11 章中，您將會把這些「輸出 XML」的程式碼替換成「輸出 VM 指令」的程式碼。
*   第 10 章確保您的編譯器能**「看懂」**程式碼（語法分析）。
*   第 11 章確保您的編譯器能**「翻譯」**程式碼（代碼生成）。

**總結來說**，第十章是關於如何教會電腦閱讀高階語言的文法結構。這是將人類可讀的代碼轉化為機器邏輯的關鍵橋樑。