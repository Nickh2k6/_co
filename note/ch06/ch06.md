# 組譯器
組譯器是一個翻譯程式，它的核心任務是將用符號機器語言（Symbolic Machine Language，即組合語言）編寫的程式，翻譯成電腦硬體可以直接執行的 Hack 二進位代碼（Binary Code）

## 組譯器的運作
1. 輸入 (Input)：一個名為 Prog.asm 的文字檔案，包含 Hack 組合語言指令。這些指令由助記符（如 D=M+1）和符號（如 @sum）組成
2. 輸出 (Output)：一個名為 Prog.hack 的文字檔案，包含由 0 和 1 組成的 16 位元字串序列，每一行對應一條機器指令

### 為了完成這個轉換，組譯器必須處理以下三個主要部分：
1. 處理指令 (Instructions)
組譯器需要將兩種主要的指令類型轉換為二進位碼：
• A-指令 (@xxx)：將符號或十進位數值轉換為 16 位元的二進位數值（開頭為 0）。
• C-指令 (dest=comp;jump)：將符號形式的計算（comp）、目的地（dest）和跳轉（jump）欄位，查表轉換為對應的二進位位元（開頭為 1）。
2. 處理空白 (White Space)
組譯器會自動忽略程式碼中的空白符號，這包括空行、縮排以及以 // 開頭的註解。這些元素是為了讓人類易讀，對機器執行沒有意義。
3. 處理符號 (Symbols)
這是組譯器最複雜也最重要的功能。它允許程式設計師使用有意義的名稱（符號）來代替無意義的數字位址。組譯器透過符號表 (Symbol Table) 來管理三種符號：
• 預定義符號 (Predefined symbols)：如 R0, SCREEN, KBD 等，它們對應到固定的 RAM 位址。
• 標籤符號 (Label symbols)：由 (LOOP) 等偽指令定義，代表程式中下一行指令的記憶體位址（用於跳轉）。
• 變數符號 (Variable symbols)：如 @i 或 @sum，組譯器會將這些自定義變數映射到從 RAM 位址 16 開始的記憶體空間。

### 運作機制：兩遍掃描 (Two-Pass)
為了正確解析在定義之前就被引用的符號（例如在程式開頭跳轉到結尾的標籤），講義建議採用兩遍掃描的策略：
* 第一遍掃描 (First pass)：讀取整個程式，專注於尋找 (label) 宣告。將這些標籤及其對應的指令行號加入符號表，此階段不產生任何二進位代碼。
* 第二遍掃描 (Second pass)：重新從頭讀取程式，逐行將指令翻譯成二進位碼。如果遇到變數符號，則查詢符號表；若表中不存在，則分配一個新的 RAM 位址給它並加入表中。

