### 1. 全域變數與對照表 (Lookup Maps)

這部分定義了 Hack 語言的語法規則，將人類可讀的符號轉換為二進位碼。

* **`dMap` (Destination Map):** 定義目的暫存器。例如 `M` 對應 `001`，表示運算結果存入 Memory。
* **`cMap` (Computation Map):** 定義計算指令。例如 `D+1` 對應 `0011111` (ALU 的控制位元)。
* **`jMap` (Jump Map):** 定義跳躍條件。例如 `JEQ` (相等時跳躍) 對應 `010`。
* **`symMap` (Symbol Map - 符號表):**
* 這是一個非常關鍵的 `map<string, int>`。
* 它預先定義了暫存器 (`R0`~`R15`)、I/O位址 (`SCREEN`, `KBD`) 和系統指標 (`SP`, `LCL` 等)。
* 它的作用是儲存 **變數** 和 **標籤 (Label)** 對應的記憶體位址。


* **`varTop = 16`:**
* Hack 電腦規定，使用者自定義的變數 (Variable) 從 RAM 的位址 16 開始存放。這個變數是用來記錄目前用到哪一個位址了。



---

### 2. 字串處理工具 (`parse`)

```cpp
char *parse(char *line) {
  // ...略...
}

```

* **功能：** 清理原始碼的一行。
* **去除空白：** 跳過前面的空格或 Tab。
* **去除註解：** 偵測 `//`，將其視為該行的結束。
* **去除換行：** 確保讀進來的字串乾淨，只剩下指令本身 (例如將 `  D=M+1 // comment` 變成 `D=M+1`)。

---

### 3. 第一階段掃描：`pass1` (建立符號表)

組譯器通常需要掃描兩次原始碼，這是第一次。

```cpp
void pass1(char *inFile) {
  // ...
  if (code[0] == '(') { // 遇到標籤，例如 (LOOP)
     // ...
     symMap[lab] = address; // 記錄標籤對應的 ROM 位址
  } else {
     address ++; // 只有實際指令才會增加位址計數器
  }
}

```

* **目的：** 找出所有的 **標籤 (Labels)**，也就是被 `()` 包起來的符號 (如 `(LOOP)`, `(END)`)。
* **邏輯：**
* 它逐行讀取檔案。
* 它維護一個 `address` (指令計數器)。
* 如果遇到 `(LOOP)`，它**不會**產生機器碼，而是把 `LOOP` 這個字串跟當前的 `address` 存入 `symMap`。這樣之後程式若寫 `@LOOP`，組譯器就知道要跳到哪一行。
* 如果是普通指令，`address` 加 1。



---

### 4. 核心翻譯邏輯：`code2binary`

這是將單行組合語言轉成 16-bit 二進位字串的核心函式。

**A. 處理 A 指令 (A-Instruction, `@xxx`)**

```cpp
if (code[0]=='@') {
   // ...
}

```

* **如果是數字 (如 `@100`)：** 直接轉成二進位。
* **如果是符號 (如 `@sum`)：**
* 先去 `symMap` 找。
* **找到 (Label 或預定義符號)：** 取出其位址。
* **沒找到 (新變數)：** 這代表使用者宣告了一個新變數 (例如 `i`)。
* 將 `i` 對應到 `varTop` (目前的變數記憶體位置，初始為 16)。
* 將 `varTop` 加 1 (下一個變數就用 17)。
* 存入 `symMap` 以便下次直接查到。




* **格式：** A 指令的二進位開頭是 `0`。

**B. 處理 C 指令 (C-Instruction, `dest=comp;jump`)**

```cpp
} else { // C 指令
   // ...
   sprintf(binary, "111%s%s%s", ccode, dcode, jcode); // 拼湊字串
}

```

* 解析字串，切分出 `dest` (存去哪)、`comp` (算什麼)、`jump` (跳去哪)。
* 查表 (`dMap`, `cMap`, `jMap`) 取得對應的二進位碼。
* **格式：** C 指令的二進位開頭是 `111`。

---

### 5. 第二階段掃描：`pass2` (產生機器碼)

這是產生最終輸出檔案的階段。

```cpp
void pass2(char* inFile, char* hackFile, char* binFile) {
  // ...
  while (fgets(...)) {
    if (line[0] == '(') {
       // 標籤在 pass1 處理過了，這裡直接忽略
    } else {
       code2binary(code, binary); // 呼叫翻譯函式
       // 寫入 .hack (純文字 '0'/'1')
       // 寫入 .bin (實際的二進位 byte)
    }
  }
  // ...
}

```

* 重新讀取一次檔案。
* 遇到標籤 `(XXX)` 就跳過。
* 遇到指令就呼叫 `code2binary` 進行翻譯。此時因為 `pass1` 已經跑過，所有的標籤 (Label) 都已經在 `symMap` 裡了，所以即使是往後跳 (Forward Jump) 的指令也能正確解析。
* 最後輸出兩個檔案：
1. **`.hack`**: ASCII 文字檔，內容是 "0011..." 這種字串 (Nand2Tetris 模擬器用)。
2. **`.bin`**: 真實的二進位檔案。



---

### 6. 主程式 (`main` 與 `assemble`)

* **`main`**: 檢查使用者有沒有輸入檔名。用法是 `./asm FileName` (不帶副檔名)。
* **`assemble`**:
1. 串接檔名產生 `FileName.asm`, `FileName.hack`, `FileName.bin`。
2. 執行 `pass1` (建立符號表)。
3. 執行 `pass2` (翻譯並輸出)。



---

### 總結流程範例

假設輸入檔案 `Add.asm`：

```asm
@2
D=A
@3
D=D+A

```

1. **Pass 1**: 掃描標籤。這裡沒有 `(...)`，所以只計算行數。
2. **Pass 2**:
* `@2` -> 翻譯為 `0000000000000010`
* `D=A` -> 查表 `dest=D`, `comp=A` -> `1110110000010000`
* `@3` -> 翻譯為 `0000000000000011`
* `D=D+A` -> 查表 `dest=D`, `comp=D+A` -> `1110000010010000`


3. **輸出**: 將上述 0/1 字串寫入 `Add.hack`。

這是一個標準且完整的 "Two-Pass Assembler" 實作。