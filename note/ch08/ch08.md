第八章（Chapter 8）的標題是 **「虛擬機 II：程式控制 (Virtual Machine II: Control)」**。

第八章的目標是完成這個 **VM 翻譯器（VM Translator）**，加入 **「流程控制（Branching）」** 與 **「函數呼叫（Function Calling）」** 的功能。

這章完成後，您的翻譯器將能夠處理現代高階語言的核心特性，並將其轉換為 Hack 組合語言。：

### 1. 程式流程控制 (Program Flow Control)
VM 語言提供了類似 goto 的指令，讓程式可以非線性執行（例如實現 `if` 判斷或 `while` 迴圈）。您需要實作以下三個指令：

*   **`label label`**：在程式碼中標記一個位置。
*   **`goto label`**：無條件跳轉到該標記位置。
*   **`if-goto label`**：條件跳轉。邏輯是：從堆疊彈出最上面的數值，如果該數值不為 0（代表 true），則跳轉；否則繼續執行下一行。

**實作細節：**
您需要將這些 VM 指令轉換為 Hack 組合語言中的跳轉指令（如 `@label`, `0;JMP`, `D;JNE` 等）。

### 2. 函數調用協議 (Function Calling Protocol)
這是本章最核心、也最複雜的部分。您需要實作一套標準機制，讓函數可以互相呼叫、傳遞參數並回傳結果。這涉及對 **「堆疊框架 (Stack Frame)」** 的精確操作。

#### A. 定義函數 (`function`)
*   **指令：** `function functionName nVars`
*   **動作：** 宣告一個函數，並保留 `nVars` 個區域變數（local variables）。
*   **實作：** 在組合語言中產生函數的入口標籤 `(functionName)`，並將 `nVars` 個 0 推入堆疊以初始化區域變數,。

#### B. 呼叫函數 (`call`)
*   **指令：** `call functionName nArgs`
*   **動作：** 暫停當前函數（Caller）的執行，保存其狀態，並跳轉到被呼叫函數（Callee）。
*   **實作（翻譯器必須產生以下步驟的 Assembly 代碼）**-：
    1.  **推入返回位址 (push return address)**：產生一個標籤（如 `Foo.bar$ret.1`），代表函數執行完後要回來的代碼行號，並將其推入堆疊。
    2.  **保存呼叫者的狀態**：依序將 `LCL`, `ARG`, `THIS`, `THAT` 指標推入堆疊。
    3.  **重設 ARG 指標**：`ARG = SP - nArgs - 5`（指向推入的第一個參數）。
    4.  **重設 LCL 指標**：`LCL = SP`（指向當前堆疊頂端，作為新函數的 Frame 開始）。
    5.  **跳轉**：執行 `goto functionName`。
    6.  **宣告返回位址標籤**：在 goto 之後放置 `(return address label)`。

#### C. 從函數返回 (`return`)
*   **指令：** `return`
*   **動作：** 結束被呼叫函數，將回傳值傳給呼叫者，並恢復呼叫者的執行環境。
*   **實作**-：
    1.  **取得 Frame 資訊**：暫存 `LCL` 的位置（稱為 `FRAME`）。
    2.  **取得返回位址**：從 `FRAME` 中計算出返回位址（`FRAME - 5`）並存入臨時變數。
    3.  **處理回傳值**：將堆疊頂端的值（回傳值）彈出，放到呼叫者的 `ARG` 位置。
    4.  **恢復 SP**：`SP = ARG + 1`（為呼叫者清理堆疊）。
    5.  **恢復環境**：依序將 `THAT`, `THIS`, `ARG`, `LCL` 恢復為 `FRAME` 中儲存的舊值。
    6.  **跳轉**：`goto` 到步驟 2 取得的返回位址。

### 3. 啟動程式碼 (Bootstrap Code)
當電腦啟動時，它需要一段程式碼來初始化環境並開始執行。您的翻譯器需要在輸出的 `.asm` 檔案開頭加入這段 **Bootstrap Code**：
1.  **初始化 SP**：將堆疊指標 (`SP`) 設為 256。
2.  **呼叫系統入口**：執行 `call Sys.init 0`（這是作業系統的初始化函數）。

### 4. 符號命名與多檔案處理
在 Project 8 中，您的翻譯器需要處理**資料夾**，將裡面所有的 `.vm` 檔案合併翻譯成一個 `.asm` 檔案。
*   **靜態變數 (Static Variables)**：為了避免不同檔案中的 `static i` 衝突，翻譯器必須將其轉換為 `FileName.i` 的形式。
*   **標籤 (Labels)**：函數內部的 `label` 和 `goto` 必須產生唯一的組合語言標籤（通常格式為 `functionName$label`），以避免不同函數使用相同標籤名稱（如 `loop`）時發生衝突。

### 5. 測試計畫 (Project 8)
講義建議分兩階段進行測試：

1.  **流程控制測試：**
    *   `BasicLoop.vm`：測試 `if-goto` 和 `label`。
    *   `FibonacciSeries.vm`：測試 `goto` 和 `if-goto`。
2.  **函數呼叫測試：**
    *   `SimpleFunction.vm`：測試 `function` 和 `return`（無 `call`）。
    *   `FibonacciElement`：完整的遞迴測試，包含 Bootstrap code。
    *   `StaticsTest`：測試多檔案與靜態變數的處理。

---

### 總結

第八章是將您的虛擬機從一個簡單的計算器升級為一台**全功能的電腦**。透過實作堆疊框架的管理（Stack Frame management），您賦予了它執行複雜程式結構（如遞迴、模組化編程）的能力。這也是編譯器後端（Compiler Backend）開發的最後一步。